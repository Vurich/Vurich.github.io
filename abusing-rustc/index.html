<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Inviting God&#39;s Wrath with Cursed Rust</title>
    
    <meta name="description" content="">
    
    <meta itemprop="name" content="Inviting God&#39;s Wrath with Cursed Rust">
    
    
    <meta name="og:title" content="Inviting God&#39;s Wrath with Cursed Rust">
    
        <meta name="image" content="http://troubles.md/floppies.png">
        <meta name="og:image" content="http://troubles.md/floppies.png">
       <meta name="og:url" content="http://troubles.md/abusing-rustc/">
    <meta name="og:site_name" content="Inviting God&#39;s Wrath with Cursed Rust">
    <meta name="og:type" content="article">
    
    <meta name="article:tag" content="">
    <link rel="stylesheet" type="text/css" href="http://troubles.md/css/style.css">
    <link rel="stylesheet" type="text/css" href="http://troubles.md/css/syntax.css">
    <script async>
        window.onload = function() {
            var possibilities = [
                 "A high-level view of low-level code",  "Writing words and reading DWORDS", 
            ];

            document.getElementById('subtitle').innerHTML = possibilities[Math.floor(possibilities.length * Math.random())];
        };
    </script>
</head>

<body>

<header>
    
    <span>
        <a href="http://troubles.md/" class="title"><strong>troubles.md</strong></a>
        <span class="dash"> - </span><p id="subtitle" class="subtitle">A high-level view of low-level code</p>
        
        
    </span>
    
    <a class="rss" href="http://troubles.md/index.xml">
        <strong>
            <svg
                xmlns="http://www.w3.org/2000/svg"
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                class="feather feather-rss"
            >
                <path d="M4 11a9 9 0 0 1 9 9">
                </path>
                <path d="M4 4a16 16 0 0 1 16 16">
                </path>
                <circle cx="5" cy="19" r="1">
                </circle>
            </svg>
        </strong>
    </a>
</header>


<div class="content">
  <h1>Inviting God&#39;s Wrath with Cursed Rust <aside></aside></h1>
  <h3 id="a-tragicomedy-in-3ish-acts">A Tragicomedy In 3(ish) Acts</h3>
<p>This article is a story about optimising the size and performance of <code>std::borrow::Cow&lt;T&gt;</code> in Rust.
It requires some basic knowledge of programming Rust, but doesn&rsquo;t require any knowledge of the kind
of low-level details of Rust&rsquo;s compilation model. We&rsquo;ll be touching on some pretty low-level
subjects later on but I&rsquo;ll explain them as we go. The optimisations will start pretty reasonable,
but will continue to get more disgusting and cursed until all hell breaks loose and the skies
themselves turn blood red with the rage of the ancients.</p>
<p>Anyway, to start things off, let&rsquo;s briefly talk about pointers.</p>
<p>Specifically, let&rsquo;s talk about <em>array</em> pointers. In C, array pointers are the same as &ldquo;normal&rdquo;
pointers, and have no size or other metadata attached. If you want to know the size of an array in
C, you have to implement that yourself. For strings, this is tradionally implemented by ending the
string with a &ldquo;sentinel value&rdquo;, so when iterating over the string you can continuously check for
this value and exit. For other arrays, this is usually implemented by supplying some metadata as an
additional parameter to the function or as a field in a struct. For a safe language like Rust,
though, this simply doesn&rsquo;t fly. Rust has a type <code>&amp;[T]</code>, which represents a borrowed array, and
<code>Box&lt;[T]&gt;</code>, which is an owned array. Both of these use the same syntax as &ldquo;normal&rdquo; pointers to a
single element, but additionally store their length using some magic in the compiler itself. You can
think of pointers in Rust being split into two different types: the pointer-to-sized-type (a pointer
to a type whose size is known at compile-time, like <code>&amp;u64</code>, <code>&amp;[u8; 10]</code>, <code>&amp;()</code>, and so forth) and
the pointer-to-unsized-type (a pointer to a type whose size is only known at runtime, such as
<code>&amp;[u8]</code>, <code>&amp;str</code> or <code>&amp;dyn Trait</code>).</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>: <span class="nb">Sized</span>
<span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">address</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>: <span class="o">!</span><span class="nb">Sized</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">address</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// Rust currently only ever uses a pointer or pointer-sized integer for the fat pointer
</span><span class="c1"></span><span class="w">    </span><span class="c1">// extra data, but in theory we could have anything here, and it could be more than just
</span><span class="c1"></span><span class="w">    </span><span class="c1">// the size of a `usize`.
</span><span class="c1"></span><span class="w">    </span><span class="n">extra_data</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This means that <code>&amp;[T]</code> and <code>Box&lt;[T]&gt;</code> are actually <em>two</em> pointer-sized integers (i.e. 64-bit on 64-
bit architectures and 32-bit on 32-bit architectures), one for the pointer to the first element and
another for the length of the array. I&rsquo;m going to explain a bit of groundwork here, to make sure
that when we start invoking dark rites to twist and bend them you&rsquo;re not totally lost.</p>
<p>So, if you&rsquo;ve actually used Rust in real code, though, you might have noticed that this doesn&rsquo;t
mention <code>Vec&lt;T&gt;</code>. <code>Box&lt;[T]&gt;</code> is not a common type in Rust, as <code>Vec&lt;T&gt;</code> is far more flexible - it
allows you to add more elements to the array at runtime without making a new array, whereas
<code>Box&lt;[T]&gt;</code> does not. The reason for this difference is that <code>Box&lt;[T]&gt;</code> only stores the number of
elements, and all those elements must be defined. <code>Vec&lt;T&gt;</code> works differently. It has a integer
representing the amount of space it has - which can be more than the number of elements actually in
the <code>Vec</code>. This means that it can allocate extra space that doesn&rsquo;t contain defined elements, and
then pushing to that <code>Vec</code> just writes into that space, without having to allocate a whole new
array. Fine so far, although it means that <code>Vec</code> sadly requires <em>three</em> pointer-sized integers.
Here&rsquo;s a quick reference:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// This is invalid syntax in Rust of course, but it&#39;s just an illustration
</span><span class="c1">// Size: 2 * size_of::&lt;usize&gt;()
</span><span class="c1"></span><span class="k">struct</span> <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">length</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Size: 2 * size_of::&lt;usize&gt;()
</span><span class="c1"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dyn_as_ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cow</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">CursedCow</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="o">&amp;**</span><span class="n">cow</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dyn_to_cow</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cow</span>: <span class="nc">CursedCow</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">borrow</span>::<span class="n">Cow</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">cow</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dyn_new_cow</span><span class="p">(</span><span class="n">cow</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">CursedCow</span><span class="o">&lt;</span><span class="nb">&#39;static</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">CursedCow</span>::<span class="n">try_owned</span><span class="p">(</span><span class="n">cow</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[repr(transparent)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Test</span><span class="p">(</span><span class="kt">u64</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">ToOwned</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Owned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_owned</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Owned</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Test</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">static_new_cow</span><span class="p">(</span><span class="n">cow</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">CursedCow</span><span class="o">&lt;</span><span class="nb">&#39;static</span><span class="p">,</span><span class="w"> </span><span class="n">Test</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">CursedCow</span>::<span class="n">try_owned</span><span class="p">(</span><span class="n">cow</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">length</span>: <span class="kt">usize</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Size: 3 * size_of::&lt;usize&gt;()
</span><span class="c1"></span><span class="k">struct</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">length</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">capacity</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><blockquote>
<p><em>NOTE</em>: If you&rsquo;re already familiar with the low-level details of Rust, you might have noticed some
things I left out of the above types. Ignore them for now, I&rsquo;ll get to it.</p>
</blockquote>
<p>So there&rsquo;s one other array type that I want to talk about, and it&rsquo;s what the rest of this article
will be focussed on. That type is <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a>. We&rsquo;ll start by talking about
<code>Cow&lt;[T]&gt;</code> and <code>Cow&lt;str&gt;</code>, although <code>Cow</code> is generic and works with other types, which we&rsquo;ll get to
later. We&rsquo;ll mostly be talking about <code>Cow&lt;[T]&gt;</code> when it comes to implementation, since <code>Cow&lt;str&gt;</code> is
the same as <code>Cow&lt;[u8]&gt;</code> at runtime - it just requires some extra invariants to be true about the
bytes it contains and so it must be a separate type. <code>Cow&lt;[T]&gt;</code>/<code>Cow&lt;str&gt;</code> can be <em>either</em> a <code>&amp;'a [T]</code>/<code>&amp;'a str</code> or a <code>Vec&lt;T&gt;</code>/<code>String</code>. They&rsquo;re useful in many cases, but one big one is in parsing.
One example of where this might be useful is if you have a parser for a programming language that
has strings that can have escape characters. You can have many strings simply be a reference into
the original program text:</p>
<pre><code>let a = &quot;Hello, world&quot;;
         ^----------^ Take a reference to these characters in the original program text
                      and use it as the string value.
</code></pre><p>If you have an escape sequence, however, you need to allocate a new <code>String</code>, which is an <em>owned</em>
string type, allocated on the heap, like <code>Box&lt;[T]&gt;</code> is an owned array type. This requests a block of
memory which doesn&rsquo;t have to follow the same lifetime rules as borrows - borrows must be created in
an <em>outer</em> scope and passed <em>inwards</em>, but owned pointers can be created in an <em>inner</em> scope and
passed back <em>outwards</em>, and in general are far more flexible, at the cost of inhibiting some
optimisations and requiring computation to be done to create and destroy them. Once we&rsquo;ve allocated
our <code>String</code>, we write a version of the string from the program text into that buffer with all the
escape sequences turned into the characters they represent. You can represent this with <code>Cow&lt;str&gt;</code> -
either <code>Cow::Borrowed(some_string_reference)</code> if the string can be taken from the program text
unchanged, or <code>Cow::Owned(some_computed_string)</code> if the string had to be edited. So how many bytes
does <code>Cow&lt;[T]&gt;</code> take up? Well, it&rsquo;s either a <code>Vec&lt;T&gt;</code> or a <code>&amp;[T]</code>, so that means that we need enough
space for <code>Vec&lt;T&gt;</code>, but we can reuse some of that space if it&rsquo;s an <code>&amp;[T]</code>, since it can only be one
or the other. A <code>Vec&lt;T&gt;</code> takes up 3 pointer-size integers, and we can reuse 2 of those for the
<code>&amp;[T]</code>, so that means we only need 3 pointer-size integers. Except we also need to store a &ldquo;tag&rdquo; for
whether it&rsquo;s a <code>Vec&lt;T&gt;</code> or an <code>&amp;[T]</code>. So that means that it&rsquo;s 3 pointer-size integers, plus a single
bit that can be either 0 for <code>Vec&lt;T&gt;</code> or 1 for <code>&amp;[T]</code>. So for 64-bit, that&rsquo;d be 3 * 64 + 1, or 193,
right?</p>
<p>Unfortunately not. You can&rsquo;t access a type at a bit offset, only at a <em>byte</em> offset. So that means
that our size has to be a multiple of 8. Easy, we round it up and have 7 unused bits, right? Well
still no. Integers have to be at an offset that is a multiple of its size. You can have a <code>u64</code>
stored at offset 8, 16, 24, 32, 40, etc, but not at an offset of 9, 10, 11, 12, and so forth. Well
easy, we just see what the largest size of integer is that we have as a field of our type (in this
case, pointer-size), and round our size up to that. So now our <code>Cow</code> type is 4 pointer-sizes in
size, or twice the size of a <code>&amp;[T]</code>. This doesn&rsquo;t sound bad, but this adds up, and there are other
downsides to this increase in size that I&rsquo;ll get to later. We can confirm the size like so:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// Prints 32 on 64-bit systems, which is 4 * 8, where 8 is the number of bytes in a 64-bit
</span><span class="c1"></span><span class="w">    </span><span class="c1">// integer
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">std</span>::<span class="n">borrow</span>::<span class="n">Cow</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="act-1-some-reasonable-optimisations">Act 1: Some Reasonable Optimisations</h2>
<p>So what can we do to help? Well there are a few things. For a start, we can notice that if the
vector has zero capacity, we can treat it identically to an empty array for most operations. Vectors
with zero capacity don&rsquo;t need their &ldquo;drop code&rdquo; ran, for example. So let&rsquo;s make a version of <code>Vec</code>
where it must always have a non-zero capacity.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">NonZeroUsize</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">NonZeroCapVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">len</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">cap</span>: <span class="nc">NonZeroUsize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>You&rsquo;ll notice that we can still have a vector with no elements, as long as it has some space to
store elements. So now, we can do our size calculations for <code>Cow&lt;[T]&gt;</code> again, replacing <code>Vec&lt;T&gt;</code>
with <code>NonZeroCapVec&lt;T&gt;</code>. Again we notice that we <code>NonZeroCapVec</code> is 3 pointer sizes, and can reuse 2
pointer sizes of that to store the slice, except now the Rust compiler knows that it can use <code>cap</code>
for both the tag and the capacity, where if <code>cap</code> is zero then it&rsquo;s a slice, and if it&rsquo;s non-zero
then it&rsquo;s a <code>Vec</code>. This is a useful trick. We can confirm that this type is now 3 pointer sizes like
so:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">CowArr</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Borrowed</span><span class="p">(</span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">]),</span><span class="w">
</span><span class="w">    </span><span class="n">Owned</span><span class="p">(</span><span class="n">NonZeroCapVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">CowArr</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Except no, sadly we actually can&rsquo;t confirm this. At the time of writing Rust doesn&rsquo;t yet optimise
this correctly, and still reports that the size is 32. This is unfortunate, but until then we can
implement this optimisation manually:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">CowArr</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// We can use `*mut` to store immutable pointers like `&amp;T`, as long as we never derive an
</span><span class="c1"></span><span class="w">    </span><span class="c1">// `&amp;mut T` from an `&amp;T`
</span><span class="c1"></span><span class="w">    </span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">len</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">cap</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Then when we need to know if the value is owned or borrowed, we can simply check if <code>cap</code> is zero.</p>
<p>Rust has <code>NonZero</code> variants for all integers, plus a <code>NonNull&lt;T&gt;</code> pointer type which acts the same
as a <code>*mut T</code>, except since Rust knows that it can&rsquo;t be null, it can use a null pointer as an enum
tag. Although Rust doesn&rsquo;t optimise the size of the enum defined above, it <em>will</em> correctly use
these <code>NonZero</code>/<code>NonNull</code> types in <code>Option</code>, which means that <code>Option&lt;Box&lt;[T]&gt;&gt;</code> is the same size as
<code>Box&lt;[T]&gt;</code> - it can use a null pointer to mean <code>None</code>. So we can make our <code>CowArr</code> type work the
same as <code>Box&lt;[T]&gt;</code> for <code>Option</code>, and let it use a null pointer to represent <code>None</code>, like so:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">NonNull</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CowArr</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">len</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">cap</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Again we can manually do the optimisation where we check <code>cap</code> for zero, but now Rust will
automatically use a null pointer for <code>ptr</code> to mean <code>None</code> if we have an <code>Option&lt;CowArr&lt;T&gt;&gt;</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// Both of these print 24 on 64-bit systems, and 12 on 32-bit systems
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">CowArr</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">CowArr</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;&gt;</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Hm, except we&rsquo;ve actually got more than just a size reduction here. To explain what I mean, we&rsquo;re
going to have to talk about assembly. For <code>std::borrow::Cow</code>, to do <code>as_ref</code> we first have to check
whether we have a <code>Cow::Borrowed</code> or a <code>Cow::Owned</code>, then if we have the former we return the borrow
we already have, and if we have the latter we do <code>&lt;Vec&lt;T&gt;&gt;::as_ref</code>, which is a pretty simple matter
of taking the <code>ptr</code> and <code>len</code> from the vector and creating a slice with that <code>ptr</code> and <code>len</code>. The
rest of the conversion is in the type system only, at runtime all doing <code>&lt;Vec&lt;T&gt;&gt;::as_ref</code> does is
copy a pointer and a length from one place to another. Well with <code>CowArr</code> our code is simpler. The
<em>borrowed</em> <code>ptr</code> and <code>len</code> is exactly the same as the <em>owned</em> <code>ptr</code> and <code>len</code>, the only difference
is that if we have an owned value then <code>cap</code> is non-zero. That means that we don&rsquo;t have to check
<code>cap</code> at all, we only have to ensure the type system parts of the conversion are correct -
essentially, we only need to ensure that we annotate lifetimes correctly. Then once the assembly is
created, the type information is removed, and we&rsquo;re left with an implementation of <code>as_ref</code> which is
essentially a no-op. Well, the Rust Playground has a &ldquo;Show Assembly&rdquo; feature, so let&rsquo;s use it:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">borrow</span>::<span class="n">Cow</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>::<span class="n">NonNull</span><span class="w">
</span><span class="w">    </span><span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">CowArr</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">len</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">cap</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// I omitted this before since it&#39;s just to silence the error that `&#39;a` is unused.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// There is more to `PhantomData` than just silencing errors, but it&#39;s out of scope
</span><span class="c1"></span><span class="w">    </span><span class="c1">// for this article.
</span><span class="c1"></span><span class="w">    </span><span class="n">_marker</span>: <span class="nc">PhantomData</span><span class="o">&lt;&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CowArr</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span>::<span class="n">slice</span>::<span class="n">from_raw_parts</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">cow_as_ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">Cow</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">cowarr_as_ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">CowArr</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Clicking &ldquo;Show Assembly&rdquo; (in release mode, of course) shows us what this compiles to. Don&rsquo;t worry, I
know assembly can be scary so I&rsquo;ve written comments:</p>
<div class="highlight"><pre class="chroma"><code class="language-gas" data-lang="gas"><span class="c">;; For the standard library `Cow`...
</span><span class="c"></span><span class="nl">cow_as_ref:</span>
    <span class="c">;; We only need to load the `ptr` once (good!)
</span><span class="c"></span>    <span class="nf">mov</span>   <span class="no">rax</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span> <span class="err">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="c">;; Unfortunately, we check the tag to load the length
</span><span class="c"></span>    <span class="nf">cmp</span>   <span class="p">[</span><span class="no">rdi</span><span class="p">],</span> <span class="mi">1</span>

    <span class="c">;; This is a pointer to the length if we have a borrowed slice
</span><span class="c"></span>    <span class="nf">lea</span>   <span class="no">rcx</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span> <span class="err">+</span> <span class="mi">16</span><span class="p">]</span>

    <span class="c">;; This is a pointer to the length if we have an owned vector
</span><span class="c"></span>    <span class="nf">lea</span>   <span class="no">rdx</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span> <span class="err">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="c">;; We use `cmov`, which will overwrite the pointer to the borrowed
</span><span class="c"></span>    <span class="c">;; slice&#39;s length with the pointer to the owned vector&#39;s length if
</span><span class="c"></span>    <span class="c">;; our `Cow`&#39;s tag shows that it is owned.
</span><span class="c"></span>    <span class="nf">cmove</span> <span class="no">rcx</span><span class="p">,</span> <span class="no">rdx</span>

    <span class="c">;; Then finally, we dereference this pointer-to-length to get the
</span><span class="c"></span>    <span class="c">;; actual length
</span><span class="c"></span>    <span class="nf">mov</span>   <span class="no">rdx</span><span class="p">,</span> <span class="p">[</span><span class="no">rcx</span><span class="p">]</span>
    <span class="nf">ret</span>

<span class="c">;; For our `CowArr`
</span><span class="c"></span><span class="nl">cowarr_as_ref:</span>
    <span class="c">;; We return the `ptr`
</span><span class="c"></span>    <span class="nf">mov</span> <span class="no">rax</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span><span class="p">]</span>
    <span class="c">;; We return the `len`
</span><span class="c"></span>    <span class="nf">mov</span> <span class="no">rdx</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span> <span class="err">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="c">;; That&#39;s it! We&#39;re done
</span><span class="c"></span>    <span class="nf">ret</span>
</code></pre></div><p>Even if you don&rsquo;t understand assembly, you can see that this is an improvement by the reduction in
instruction count, if nothing else. It also reduces register pressure, although if you don&rsquo;t know
what that means then don&rsquo;t worry - its effect is small enough that you don&rsquo;t need to worry about it
for now.</p>
<p>If you know anything about calling conventions, you might notice something a bit odd about that
assembly code. We&rsquo;ll get to it in due time, although not until after we pass through into the
Forbidden Realms.</p>
<h2 id="act-2-stepping-into-the-forbidden-realms">Act 2: Stepping into the Forbidden Realms</h2>
<p>So far, so simple. But we can do better, if we&rsquo;re willing to add some restrictions. We can&rsquo;t reduce
the size of <code>ptr</code> since it&rsquo;s not really possible to safely make many assumptions about the range of
values a pointer can take, but the same can&rsquo;t be said for <code>len</code> and <code>cap</code>. If we&rsquo;re on a 64-bit
system, using a 64-bit length and capacity allows us to store up to 18,446,744,073,709,551,615
elements, which I think we can agree that it&rsquo;s unlikely for a single array to contain this many
items in the majority of programs. In fact, it&rsquo;s not even possible to create an array this large for
anything other than <code>u8</code> and other single-byte (<a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">or even smaller</a>) types, since you&rsquo;ll run out
of address space long before that, not even mentioning that you&rsquo;ll run out of memory on your
computer long before you run out of address space. So let&rsquo;s say that <code>len</code> and <code>cap</code> are both 32-bit
on 64-bit systems. We&rsquo;ll ignore 32-bit for now, on 32-bit systems we could choose to either make
both <code>len</code> and <code>cap</code> 16-bit, or fall back to the implementation in the previous section. This choice
isn&rsquo;t really important for now, so I&rsquo;ll focus on 64-bit. With 32-bit <code>len</code> and <code>cap</code> we can store
arrays with up to 4,294,967,295 elements, which means, for example, that a single string can be up
to 4Gb long. This is a restriction, certainly, it&rsquo;s not unbelievable that your program would want to
process larger strings, but the standard library <code>Cow</code> will always support that if you need it. If
you don&rsquo;t need that many elements, then this gives you a size reduction.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">NonNull</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CowArr</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">len</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">cap</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// Both of these print 16 on 64-bit systems, and still print 12 on 32-bit systems
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">CowArr</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">CowArr</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;&gt;</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>If you&rsquo;re anything like me, saving 8 bytes like this is enough to make you cry with joy, but maybe
we can do better. Now we get back to that &ldquo;something a bit odd&rdquo; that I mentioned above. See, when
Rust passes a struct into a function or returns a struct from a function, it has a couple of ways to
handle sharing the struct between the caller and the callee. If the struct is &ldquo;small&rdquo; (meaning two
fields or less, with each field fitting into a single register), then the struct will be passed as
an argument in registers, and returned in registers. Otherwise, the struct will be written to stack
and a pointer to the struct will be passed to the callee. This is the &ldquo;something a bit odd&rdquo; that I
mentioned before - many people assume that Rust <em>always</em> passes structs with more than 1 element by
pointer, and in fact until relatively recently it did. Now, if you&rsquo;re as much of a rules-lawyer as
me, you might notice a trick we can do here: although the struct above is <em>not</em> considered &ldquo;small&rdquo;
by Rust, we can make a version of it that <em>is</em> considered small. Let&rsquo;s do that:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">NonNull</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CowArr</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">len_cap</span>: <span class="kt">u64</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">LEN_MASK</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="kt">u32</span>::<span class="n">MAX</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">CAP_MASK</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">LEN_MASK</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// We want the low 32 bits of `len_cap` to be `len`, and the high 32 bits to be `cap`,
</span><span class="c1">// so we need to shift `cap` when reading and writing it.
</span><span class="c1"></span><span class="k">const</span><span class="w"> </span><span class="n">CAP_SHIFT</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CowArr</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span>::<span class="n">slice</span>::<span class="n">from_raw_parts</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LEN_MASK</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>So sure, now we have a struct that&rsquo;s the same size, but can be passed in registers, speeding up
function calls that use it. Cool, but isn&rsquo;t that <code>&amp;</code> to mask the length going to add an additional
cost? Well luckily for us, x86 has a way to mask the lower bits of a number for free! Since assembly
is untyped, we can just pretend that our 64-bit number is a 32-bit number whenever we&rsquo;re using it,
and it&rsquo;ll be the same as if we had masked the lower 32 bits. Additionally, we only have to allocate
stack space and pass a pointer to the callee when we actually need to pass a reference to the <code>Cow</code>.
If we pass an owned value, it&rsquo;ll just stay in registers. Let&rsquo;s see the assembly here to see what I
mean:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">CowArr3Fields</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">len</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">cap</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CowArr2Fields</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">len_cap</span>: <span class="kt">u64</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">cow_as_ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">Cow</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">cowarr2fields_as_ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">CowArr2Fields</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">cowarr3fields_as_ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">CowArr3Fields</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">cow_noop</span><span class="p">(</span><span class="n">a</span>: <span class="nc">Cow</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cow</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">cowarr2fields_noop</span><span class="p">(</span><span class="n">a</span>: <span class="nc">CowArr2Fields</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">CowArr2Fields</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">cowarr3fields_noop</span><span class="p">(</span><span class="n">a</span>: <span class="nc">CowArr3Fields</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">CowArr3Fields</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-gas" data-lang="gas"><span class="nl">cow_as_ref:</span>
    <span class="nf">mov</span>   <span class="no">rax</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span> <span class="err">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="nf">cmp</span>   <span class="p">[</span><span class="no">rdi</span><span class="p">],</span> <span class="mi">1</span>
    <span class="nf">lea</span>   <span class="no">rcx</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span> <span class="err">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="nf">lea</span>   <span class="no">rdx</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span> <span class="err">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="nf">cmove</span> <span class="no">rcx</span><span class="p">,</span> <span class="no">rdx</span>
    <span class="nf">mov</span>   <span class="no">rdx</span><span class="p">,</span> <span class="p">[</span><span class="no">rcx</span><span class="p">]</span>
    <span class="nf">ret</span>

<span class="nl">cowarr2fields_as_ref:</span>
    <span class="nf">mov</span> <span class="no">rax</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="no">edx</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span> <span class="err">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="nf">ret</span>

<span class="nl">cowarr3fields_as_ref:</span>
    <span class="nf">mov</span> <span class="no">rax</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="no">edx</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span> <span class="err">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="nf">ret</span>
    
<span class="nl">cow_noop:</span>
    <span class="nf">mov</span>    <span class="no">rax</span><span class="p">,</span> <span class="no">rdi</span>
    <span class="nf">movups</span> <span class="no">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="no">rsi</span><span class="p">]</span>
    <span class="nf">movups</span> <span class="no">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="no">rsi</span> <span class="err">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="nf">movups</span> <span class="p">[</span><span class="no">rdi</span> <span class="err">+</span> <span class="mi">16</span><span class="p">],</span> <span class="no">xmm1</span>
    <span class="nf">movups</span> <span class="p">[</span><span class="no">rdi</span><span class="p">],</span> <span class="no">xmm0</span>
    <span class="nf">ret</span>

<span class="nl">cowarr2fields_noop:</span>
    <span class="nf">mov</span> <span class="no">rdx</span><span class="p">,</span> <span class="no">rsi</span>
    <span class="nf">mov</span> <span class="no">rax</span><span class="p">,</span> <span class="no">rdi</span>
    <span class="nf">ret</span>

<span class="nl">cowarr3fields_noop:</span>
    <span class="nf">mov</span>    <span class="no">rax</span><span class="p">,</span> <span class="no">rdi</span>
    <span class="nf">movups</span> <span class="no">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="no">rsi</span><span class="p">]</span>
    <span class="nf">movups</span> <span class="p">[</span><span class="no">rdi</span><span class="p">],</span> <span class="no">xmm0</span>
    <span class="nf">ret</span>
</code></pre></div><p>If you can read assembly, you can see that just returning an unmodified <code>Cow</code> requires some messing
around with loading and storing data for all the structs apart from <code>CowArr2Fields</code>. If you can&rsquo;t
read assembly, then all you need to know is that the <code>[...]</code> square brackets is a memory access, and
<code>cowarr2fields_noop</code> is the only function that doesn&rsquo;t need them.</p>
<p>Ok, so we&rsquo;ve optimised the <code>Cow</code> arrays about as much as we can. Now is when we start to invoke the
Dark Magicks and risk the wrath of the Old Ones (you know, the Rust core team). Let&rsquo;s make a
&ldquo;generic&rdquo; optimised <code>Cow</code>, one that works with more than just arrays.</p>
<h2 id="act-3-forgive-me">Act 3: Forgive Me</h2>
<p>So this is all well and good, but it&rsquo;s <em>just not cursed enough</em>. It basically reimplements
<code>Cow&lt;[T]&gt;</code> with a custom type that doesn&rsquo;t work for <code>Cow&lt;str&gt;</code> - you have to write your own wrapper,
maybe call it <code>CowStr</code>. Then repeat that for every type. No, we can do better. We can make a
<code>CursedCow</code> that you works the same no matter if it&rsquo;s <code>CursedCow&lt;[T]&gt;</code>, <code>CursedCow&lt;str&gt;</code>, or even
<code>CursedCow&lt;dyn Trait&gt;</code>. That last one is where the code really starts to cause damage to the soul.
If you find yourself cast into Hell one day, just know that it may be because you read this article.
I think we can both agree that this is a fair and just punishment. Anyway, before we can truly damn
ourselves, we need to lay down the groundwork and make the far-simpler
<code>CursedCow&lt;[T]&gt;</code>/<code>CursedCow&lt;str&gt;</code> work. To make this work, we&rsquo;ll need a trait.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Cursed</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span>: <span class="nc">Borrow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">borowed</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_owned</span><span class="p">(</span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">reconstruct</span><span class="p">(</span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This trait is actually implemented for the <em>owned</em> variant, as opposed to <code>ToOwned</code> which is
implemented for the <em>borrowed</em> variant. This is because many types may implement <code>ToOwned</code> pointing
to the same type (you could imagine a slice wrapper where <code>ToOwned</code> still generates a <code>Vec</code>), but we
still want to explicitly single out <code>Box</code> and other smart pointers. Implementing for the owned
variant means that we don&rsquo;t have to write any generic implementations with <code>impl&lt;T&gt; Cursed for T where ...</code>, which lets us circumvent the issue of overlapping implementations. The trait is unsafe,
as it requires some invariants to be true about <code>Borrow</code>, and requires <code>borrowed</code>, <code>owned</code> and
<code>is_owned</code> to be in agreement about what borrowed and owned pointers look like. Additionally,
<code>as_ref</code> and <code>reconstruct</code> need to be unsafe functions because they should only ever have valid
pointers passed into them.</p>
<p>So, let&rsquo;s write the actual <code>CursedCow</code> struct now. So while in the previous sections we&rsquo;ve been
basically reimplementing Rust&rsquo;s &ldquo;fat pointer&rdquo; system, we can&rsquo;t do that any more if we want to
support more than just arrays. We want to have a 2-pointer-width <code>CursedCow&lt;T&gt;</code> if <code>T</code> is unsized
(such as <code>[T]</code>, <code>str</code> or <code>dyn Trait</code>) and a 1-pointer-width <code>CursedCow&lt;T&gt;</code> - just a regular pointer -
if <code>T</code> is sized. We do this by just using <code>NonNull&lt;T&gt;</code>, which is a fat pointer for unsized types,
and letting the implementation of <code>Cursed</code> handle hiding the tag somewhere.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// `repr(transparent)` ensures that this struct is always treated exactly the same as `NonNull&lt;T&gt;`
</span><span class="c1">// at runtime.
</span><span class="c1"></span><span class="cp">#[repr(transparent)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">CursedCow</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">ToOwned</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>::<span class="n">Owned</span>: <span class="nc">Cursed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">_marker</span>: <span class="nc">PhantomData</span><span class="o">&lt;&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Apart from the fact that you can&rsquo;t explicitly match on its variants (or get a mutable reference to
the internals, but there are ways around this) this is identical to <code>std::borrow::Cow</code> - you don&rsquo;t
do <code>CowArr&lt;T&gt;</code>, you just do <code>CursedCow&lt;[T]&gt;</code>, and this new <code>CursedCow</code> is 2 pointers wide. This is
the same as before for 64-bit, although smaller on 32-bit at the cost of only allowing up to 65,535
elements.</p>
<p>Implementing the necessary methods for our new <code>CursedCow&lt;T&gt;</code> - methods to construct it from owned
or borrowed data, a <code>Deref</code> implementation, <code>Drop</code> implementation, and so forth - is pretty easy so
I&rsquo;ll skip it, but you can see it in the full gist (linked at the end of the article).</p>
<p>The real work is done in the implementations of <code>Cursed</code> for <code>Vec&lt;T&gt;</code>, <code>String</code>, <code>Box&lt;T&gt;</code> and so
forth. I&rsquo;ll skip over the implementation for <code>String</code> for now since it&rsquo;s basically the same as
<code>Vec&lt;T&gt;</code>, but let&rsquo;s start with an explanation of how we store all the information needed for a
<code>CursedCow&lt;[T]&gt;</code> in a single <code>NonNull&lt;[T]&gt;</code>. You&rsquo;ll see these constants <code>CAP_SHIFT</code>, <code>CAP_MASK</code> and
<code>LEN_MASK</code> referenced in the following functions, so I&rsquo;ll start by defining them here:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">CAP_SHIFT</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">LEN_MASK</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="kt">usize</span>::<span class="n">MAX</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">CAP_SHIFT</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">CAP_MASK</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">LEN_MASK</span><span class="p">;</span><span class="w">
</span></code></pre></div><p><code>CAP_SHIFT</code> is the amount you need to shift the <code>len</code> field of the <code>NonNull&lt;[T]&gt;</code> fat pointer to get
the capacity that we&rsquo;ve hidden in that field - i.e., the upper 32/16 bits (on 64- and 32-bit,
respectively). <code>LEN_MASK</code> and <code>CAP_MASK</code> are the &ldquo;masks&rdquo; for these bits, so we can use bitwise <code>&amp;</code>
to only get the bits that represent the length or the capacity, respectively.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cursed</span><span class="o">&lt;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">ptr</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">ptr</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CAP_MASK</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// Fail if the capacity is too high
</span><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CAP_MASK</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CAP_MASK</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span>::<span class="n">ManuallyDrop</span>::<span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="n">slice</span>::<span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="w">
</span><span class="w">                    </span><span class="n">this</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">                    </span><span class="c1">// This combines the length and capacity into a single `usize`
</span><span class="c1"></span><span class="w">                    </span><span class="n">this</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">CAP_SHIFT</span><span class="p">),</span><span class="w">
</span><span class="w">                </span><span class="p">)))</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...snip...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>So here you can see our checks that the length of the borrowed/owned values don&rsquo;t exceed the amount
we can represent in the reduced amount of space that we have. If we have too many elements or too
much capacity, we return <code>None</code>, since there&rsquo;s no way for us to store that. Although we could
truncate the <code>len</code>, we can&rsquo;t safely truncate the capacity without breaking some allocators, and
truncating <code>len</code> would be a footgun. Otherwise, this looks pretty much the same as what we had
before.</p>
<p>The rest of the trait is implemented essentially how you&rsquo;d expect, and it looks pretty much the same
as <code>CowArr</code> that we had before. This whole trait implementation looks basically exactly the same for
<code>String</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cursed</span><span class="o">&lt;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...snip...
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_owned</span><span class="p">(</span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w"> </span><span class="p">}.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CAP_MASK</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// Like before, this mask is essentially free because we can just treat `self.len`
</span><span class="c1"></span><span class="w">        </span><span class="c1">// like a smaller value, which acts the same as if we did the mask, instead of
</span><span class="c1"></span><span class="w">        </span><span class="c1">// actually masking.
</span><span class="c1"></span><span class="w">        </span><span class="n">slice</span>::<span class="n">from_raw_parts</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LEN_MASK</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">reconstruct</span><span class="p">(</span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Vec</span>::<span class="n">from_raw_parts</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LEN_MASK</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">CAP_SHIFT</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Well there we go, that&rsquo;s it. Now our new <code>CursedCow&lt;[T]&gt;</code> acts like <code>CowArr&lt;T&gt;</code> automatically. It&rsquo;s
pretty cursed to hide the tag and capacity inside the <code>len</code> field of a slice, but we&rsquo;re just getting
started</p>
<p>Now we get to the jankiest part of all - <code>CursedCow&lt;T&gt;</code> for other values of <code>T</code>, and specifically
<code>CursedCow&lt;dyn Trait&gt;</code>. Now, we can&rsquo;t be generic over any <code>CursedCow&lt;dyn Trait&gt;</code>, since there&rsquo;s no
way to specify &ldquo;some trait object&rdquo; in the type system, but let&rsquo;s say that if you&rsquo;re using
<code>CursedCow&lt;dyn Trait&gt;</code> for one reason or another then might have an implementation of <code>ToOwned</code> that
has <code>Owned = Box&lt;dyn Trait&gt;</code>, since that&rsquo;s the only way to have an owned trait object. That might
look something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">MyCoolTrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone_boxed</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ... the rest of my cool functions... 
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">ToOwned</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">MyCoolTrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Owned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">MyCoolTrait</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_owned</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="nb">ToOwned</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">clone_boxed</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>So, how do we store a tag representing the owned-or-borrowed tag in a <code>Box&lt;T&gt;</code>, since <code>Box</code> also
uses the possibly-fat-pointer <code>NonNull&lt;T&gt;</code> internally? Well, there are a couple methods, both
relying on the fact that not all the bits of pointers get used. For a start, most types have an
alignment greater than 1. We mentioned alignment further up - u64s can only be at locations that are
a multiple of <code>mem::size_of::&lt;u64&gt;()</code>, u32s can only be at locations that are a multiple of
<code>mem::size_of::&lt;u32&gt;()</code>, and so forth. So because of this, we know that if the integer value of a
pointer is odd then it <em>must</em> be invalid. We can use this to store a tag - if the pointer is odd
then it&rsquo;s owned (and we should subtract 1 to get the true pointer), if it&rsquo;s even then it&rsquo;s just a
normal borrowed pointer. That would be a pretty cursed implementation of <code>Cow</code>, for sure, but we
can&rsquo;t implement it generically, and we can&rsquo;t implement it for <code>dyn Trait</code> since that would lead to
weird bugs where <code>Cow&lt;dyn Trait&gt;</code> was fine for most types, but doesn&rsquo;t work if the implementation of
your trait <em>happens</em> to have a size of 1, and you wouldn&rsquo;t know that until it explodes at runtime.</p>
<p>Another possibility is that Rust goes out of its way to make sure that pointers can&rsquo;t overflow an
<code>isize</code>, since this means that adding two pointers together will never overflow. As far as I know
this isn&rsquo;t a hard guarantee, but certainly on 64-bit x86 it&rsquo;s not even possible on any hardware that
exists in the real world to have a pointer larger than 63 bits, so that 64th bit will always be 0.
We can take advantage of that, and if we get given a pointer that happens to have the top bit set,
we can just return <code>None</code>, the same as if we get given a <code>&amp;[T]</code>/<code>Vec&lt;T&gt;</code> that&rsquo;s too large to store.
Now, manually manipulating the pointer field of a fat pointer isn&rsquo;t allowed in Rust - we can do
arithmetic on a normal, &ldquo;thin&rdquo; pointer, but there&rsquo;s no way to mutate the pointer field of a fat
pointer. However, we can work around this doing a pointer-to-pointer cast, which is undefined
behaviour in C but not in Rust. This is wildly unsafe, and we need to be extremely careful to make
it work at all, let alone make it work in a way that won&rsquo;t immediately cause undefined behaviour.
Here&rsquo;s the cursed function at the heart of it all, which allows us to treat the data pointer of a
fat pointer as if it&rsquo;s a <code>usize</code>, and so allows us to manipulate its bits directly.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">update_as_usize</span><span class="o">&lt;</span><span class="n">O</span><span class="p">,</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">O</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">func</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">O</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// Here&#39;s where we invoke the darkest of dark magic, explanation below.
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr_as_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span>::<span class="n">transmute</span>::<span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="c1">// Since this is dark magic, we make sure that we explode if our
</span><span class="c1"></span><span class="w">        </span><span class="c1">// assumptions are wrong.
</span><span class="c1"></span><span class="w">        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">ptr_as_bytes</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">func</span><span class="p">(</span><span class="n">ptr_as_bytes</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>The way this works assumes that the layout of the fat pointer has the data pointer first.
Essentially, the fat pointer for <code>NonNull&lt;dyn Trait&gt;</code> looks like this, and in fact you can find this
exact struct in <code>std::raw::TraitObject</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">TraitObject</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="n">vtable</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>However, even with nightly Rust we can&rsquo;t use <code>std::raw::TraitObject</code>, since it doesn&rsquo;t work for
<em>any</em> fat pointer, only <code>dyn Trait</code>, and as mentioned before we can&rsquo;t be generic over &ldquo;any trait
object&rdquo;. So we have to make the further assumption that not only do trait objects have the data
pointer first, but <em>all</em> fat pointers have the data pointer first. That&rsquo;s what the <code>assert_eq</code> in
<code>update_as_usize</code> does: it uses Rust&rsquo;s native ability to convert the pointer to a thin <code>*mut u8</code> to
make sure that our mutable pointer-to-usize is pointing at the right data. This is <em>wildly unsafe</em>,
and although it&rsquo;s likely to work for the forseeable future for all the fat pointers that Rust
supports, there&rsquo;s no guarantee that this will be the case, and if this ever becomes incorrect in a
way that the <code>assert_eq</code> doesn&rsquo;t catch then you&rsquo;ll get undefined behaviour. So for now we&rsquo;ll keep
using this, because it works, but I want to stress that you should <em><strong>NOT USE THIS IN REAL
SOFTWARE</strong></em>, unless you want to get fired and deserve it.</p>
<p>Anyway, since this works just fine for now, let&rsquo;s explore these cursed realms a little further,
shall we?</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// The mask for the actual pointer
</span><span class="c1"></span><span class="k">const</span><span class="w"> </span><span class="n">PTR_MASK</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="kt">usize</span>::<span class="n">MAX</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// The mask for just the &#34;is owned&#34; tag
</span><span class="c1"></span><span class="k">const</span><span class="w"> </span><span class="n">TAG_MASK</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">PTR_MASK</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cursed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">ptr</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// We use `Self::is_owned` here to avoid duplicating information. You can think of this
</span><span class="c1"></span><span class="w">        </span><span class="c1">// in this context as expressing &#34;if we _would think_ that `ptr` was owned&#34;
</span><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">Self</span>::<span class="n">is_owned</span><span class="p">(</span><span class="n">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span>::<span class="n">ManuallyDrop</span>::<span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">original_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">**</span><span class="n">this</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">original_ptr</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">update_as_usize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">TAG_MASK</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">Self</span>::<span class="n">is_owned</span><span class="p">(</span><span class="n">NonNull</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="n">original_ptr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">this</span><span class="p">.</span><span class="n">into_inner</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="nb">None</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">NonNull</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_owned</span><span class="p">(</span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">TAG_MASK</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">update_as_usize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="n">PTR_MASK</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;*</span><span class="n">ptr</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">reconstruct</span><span class="p">(</span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">update_as_usize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="n">PTR_MASK</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>So there we go, apart from the implementations of the traits you&rsquo;d expect from a <code>Cow</code>
implementation, which should be fairly self-explanatory, and a <code>Drop</code> implementation, which is also
pretty simple, this is more-or-less a fully-working drop-in replacement for <code>std::borrow::Cow</code>.
Finally, let&rsquo;s see what the codegen looks like for this implementation of <code>Cursed</code> for <code>Box&lt;T&gt;</code>. You
can just take my word for it that <code>CursedCow&lt;[T]&gt;</code> generates exactly the same code as <code>CowArr&lt;T&gt;</code>.
Let&rsquo;s write the code for a couple of different scenarios that we want to test the codegen for -
first for fat pointers, and then for thin pointers (if for some reason you had a <code>ToOwned</code>
implementation for a non-dynamically-sized type that still used <code>Box</code> when it&rsquo;s owned).</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dyn_as_ref</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cow</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">CursedCow</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="o">&amp;**</span><span class="n">cow</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dyn_to_cow</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cow</span>: <span class="nc">CursedCow</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">borrow</span>::<span class="n">Cow</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">cow</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dyn_new_cow</span><span class="p">(</span><span class="n">cow</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">CursedCow</span><span class="o">&lt;</span><span class="nb">&#39;static</span><span class="p">,</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Foo</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">CursedCow</span>::<span class="n">try_owned</span><span class="p">(</span><span class="n">cow</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[repr(transparent)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Test</span><span class="p">(</span><span class="kt">u64</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">ToOwned</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Owned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_owned</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Owned</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Test</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">static_new_cow</span><span class="p">(</span><span class="n">cow</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">CursedCow</span><span class="o">&lt;</span><span class="nb">&#39;static</span><span class="p">,</span><span class="w"> </span><span class="n">Test</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">CursedCow</span>::<span class="n">try_owned</span><span class="p">(</span><span class="n">cow</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>The code made by these functions is pretty amazingly minimal, and almost entirely avoids using the
stack - keeping most values in registers. I won&rsquo;t explain this assembly fully, but it&rsquo;s here for
completeness:</p>
<pre><code>dyn_as_ref:
    mov    rdx, [rdi + 8]
    movabs rax, 9223372036854775807
    and    rax, [rdi]
    ret

dyn_to_cow:
    mov    rax, rdi
    movabs rcx, 9223372036854775807
    and    rcx, rsi
    test   rsi, rsi
    jns    .is_ref
    mov    esi, 1
    mov    [rax + 8], rcx
    mov    [rax + 16], rdx
    mov    [rax], rsi
    ret
.is_ref:
    xor    esi, esi
    mov    [rax + 8], rcx
    mov    [rax + 16], rdx
    mov    [rax], rsi
    ret

dyn_new_cow:
    mov    rdx, rsi
    movabs rcx, -9223372036854775808
    or     rcx, rdi
    xor    eax, eax
    test   rdi, rdi
    cmovns rax, rcx
    ret

static_new_cow:
    movabs rcx, -9223372036854775808
    or     rcx, rdi
    xor    eax, eax
    test   rdi, rdi
    cmovns rax, rcx
    ret
</code></pre><p>Anyway, if you want to try this out then I recommend the <a href="https://crates.io/crates/beef/"><code>beef</code> crate</a>, which acts as a drop-
in replacement for <code>std::borrow::Cow</code> for most cases. It&rsquo;s written by my colleague and friend, and
this article came about due to discussions about how to optimise that crate for the usecase of
parsing JSON. It doesn&rsquo;t include our incredibly sketchy <code>dyn Trait</code> implementation, thank god.
There&rsquo;s also the simpler <a href="https://crates.io/crates/cowvec/"><code>cowvec</code> crate</a>, which is my earlier implementation, roughly
equivalent to the code we had at the end of Act 2. I&rsquo;d only recommend <code>beef</code> over <code>cowvec</code> because
<code>cowvec</code> doesn&rsquo;t act as a drop-in replacement as it has a different signature to <code>std::borrow::Cow</code>.
Well, that and the fact that <code>beef</code> is clearly the far better name.</p>
<p>The <a href="https://github.com/simd-lite/simdjson-rs">JSON-parsing crate <code>simdjson-rs</code></a> actually integrated <code>beef</code> recently, and you can
see the improvements to throughput that they saw <em>just from switching out their <code>Cow</code>
implementation</em> in the <a href="https://github.com/simd-lite/simdjson-rs/pull/113">integration PR</a>.</p>
<p>Now if you don&rsquo;t mind, I&rsquo;m going to go seek the advice of a priest.</p>
<blockquote>
<p><strong>NOTE</strong>: This article originally contained an extended section about how to extend this
implementation to support inlining data, but this was considered too cursed for the eyes of mere
mortals. Perhaps after I&rsquo;ve thoroughly cleansed myself with holy water, I may be able to bring
myself to write an additional article detailing how to implement this within our existing
framework.</p>
</blockquote>

</div>

<footer>
	<p>© 2017-2018, all rights reserved.</a>
</footer>
</body>
</html>
