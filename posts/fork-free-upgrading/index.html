<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Never Fork Again</title>
    
    <meta name="description" content="">
    
    <meta itemprop="name" content="Never Fork Again">
    
    
    <meta name="og:title" content="Never Fork Again">
    
        <meta name="image" content="http://troubles.md/floppies.png">
        <meta name="og:image" content="http://troubles.md/floppies.png">
       <meta name="og:url" content="http://troubles.md/posts/fork-free-upgrading/">
    <meta name="og:site_name" content="Never Fork Again">
    <meta name="og:type" content="article">
    
    <meta name="article:tag" content="">
    <link rel="stylesheet" type="text/css" href="http://troubles.md/css/style.css">
    <link rel="stylesheet" type="text/css" href="http://troubles.md/css/syntax.css">
    <script async>
        window.onload = function() {
            var possibilities = [
                 "A high-level view of low-level code",  "Writing words and reading DWORDS", 
            ];

            document.getElementById('subtitle').innerHTML = possibilities[Math.floor(possibilities.length * Math.random())];
        };
    </script>
</head>

<body>

<header>
    
    <span>
        <a href="http://troubles.md/" class="title"><strong>troubles.md</strong></a>
        <span class="dash"> - </span><p id="subtitle" class="subtitle">A high-level view of low-level code</p>
        
        
    </span>
    
    <a class="rss" href="http://troubles.md/index.xml">
        <strong>
            <svg
                xmlns="http://www.w3.org/2000/svg"
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                class="feather feather-rss"
            >
                <path d="M4 11a9 9 0 0 1 9 9">
                </path>
                <path d="M4 4a16 16 0 0 1 16 16">
                </path>
                <circle cx="5" cy="19" r="1">
                </circle>
            </svg>
        </strong>
    </a>
</header>


<div class="content">
  <h1>Never Fork Again <aside></aside></h1>
  <p>It&rsquo;s no secret in the blockchain world that upgrading an existing blockchain sucks. It sucks hard. It sucks even harder than Kevin Pham&rsquo;s hot takes. Blockchains are essentially copy-on-write: there&rsquo;s no way to actually &ldquo;upgrade&rdquo; a blockchain in the traditional sense, only create a new blockchain that wears the skin of the original like Ed Gein and that everyone agrees to continue using the same name for. Like if you replace your dead dog with another of the same breed that acts differently but everyone calls the same name for the sake of the kids, except the original dog isn&rsquo;t dead and the new dog has all the memories of the original dog surgically implanted into its brain and actually this metaphor doesn&rsquo;t work so well. Anyway, you get the point. No upgrades, only forks. This has been the paradigm for as long as there have been blockchains. There&rsquo;s probably some old computer in someone&rsquo;s cupboard still running a Bitcoin miner from 2009 and if you could find a compatible client you could still connect to that network.</p>

<p>This is a problem with distributed systems in general, but it&rsquo;s <em>really</em> a problem with decentralised systems like Bitcoin where no one entity controls all the computers on the network. You can&rsquo;t call up every Bitcoin miner and tell them that they have to upgrade. You <em>can</em> call up every Bitcoin miner that actually matters, but that&rsquo;s a bug and not a feature of the Bitcoin network. The way we realistically deal with this nowadays is to upgrade clients way ahead of time, with the upgraded client supporting both versions of the network and an if statement that switches to the new code at a certain block number. This works just fine for now, but it doesn&rsquo;t really fix the problem, it just buys you time. Besides, it&rsquo;s uncivilised. When London votes for a mayor, it doesn&rsquo;t split along political lines into London and London Classic, they choose the mayor that makes the most people happy (or more accurately, that makes the most people the least unhappy). This kind of formalised governance system is what is needed to reduce uncertainty in the blockchain ecosystem. Right now, it&rsquo;s impossible to have a long-running light client like you&rsquo;d find in an IoT device without trusting a third party to supply you with regular, trusted updates. Most IoT manufacturers, in fact, will not update at all if they can get away with it. There are many difficulties with updating an IoT device, also most of manufacturers just don&rsquo;t care. Mirai would not have happened if IoT manufacturers could be trusted to update their software with the reliability that is required for running a blockchain node.</p>

<p>Another solution to this, of course, is to never update. That&rsquo;s Bitcoin&rsquo;s solution for the most part, although the community cares less about long-running light clients and governance than they do about invalidating the ASIC investment of the 10 miners that get any of the rewards. We&rsquo;ll invalidate this solution for the sake of this article, though, since I think most people would agree that updating your software is a good thing and usually a good heuristic for what to think about a subject is whatever&rsquo;s the opposite of what Bitcoin people believe.</p>

<p>I&rsquo;m also going to avoid talking about any particular form of governance here, a magical &ldquo;dev key&rdquo; that must sign new updates is just as valid as a coinvote. Both of these techniques suck and you should absolutely not use either of them, though.</p>

<p>One way you could get clients to update is to deploy the entire client on-chain. You could have some method of on-chain governance choose whether or not that client is accepted, and then if it is then all the clients across the world can install the new version and (Linux) fork instead of (blockchain) fork. Well, of course, you can&rsquo;t just deploy binaries on the blockchain - for a start, that basically grants the government the ability to run arbitrary code on anyone&rsquo;s computer. This doesn&rsquo;t just mean they can do anything they like to the blockchain, but they can turn your computer into a botnet node, they can fill your pictures folder with [acrylic paintings of Danny DeVito]<a href="seriously, that's a shockingly well-stocked genre of art">danny-devito-paintings</a> or even - God forbid - mine Bitcoin. Even if you trust the government completely, it&rsquo;s a big logistical problem to deploy a binary for every OS and every architecture available.</p>

<p>So let&rsquo;s say that we run the whole client in a virtual machine. We write it in Java or Scala and we deploy Java bytecode on the blockchain, or we do something similar to Apple and write our code in a LLVM-backed compile-to-native language and deploy LLVM bitcode. Well, this is better, but no matter the VM format you use you&rsquo;re heavily limiting the languages that you can build a client in. Plus you&rsquo;re still deploying a gigantic blob on the blockchain, where space is at a premium (or <em>should</em> be at a premium, but realistically storage rent isn&rsquo;t widely implemented). This is ignoring the fact that when you build a LLVM language you generate different bitcode depending on the OS - Apple can only get away with it because their OS&rsquo;s on the different devices that they deploy to have compatible APIs.</p>

<p>Finally, any strategy that deploys the whole client on-chain is eventually going to hit the problem that handling rollbacks turns the whole thing into a comical farce, because the rollback strategy is defined by the very thing that you&rsquo;re rolling back. There&rsquo;s no good answer to defining a fork-choice rule or rollback strategy in the face of on-chain updates.</p>

<p>Well, let&rsquo;s say that we separate out the code that defines the blockchain&rsquo;s logic from the rest of the code and compile <em>just that</em> to a VM bytecode. By &ldquo;the blockchain&rsquo;s logic&rdquo; I mean the code that defines that the blockchain <em>does</em>. Ethereum <em>does</em> accounts, balances and smart contracts. ZCash <em>does</em> zero-knowledge proofs of transactions. Bitcoin <em>does</em> extremely inefficient basic accounting. In the general case, it&rsquo;s the code that tells us how to change the state in response to a transaction. We can still have competition on networking, speed of implementation etc, and although that means we can&rsquo;t update the networking code using this method, keeping multiple different versions of nodes in a distributed network is a much better-solved problem than having those nodes acheive consensus on a constantly updating mutable state. We can use an extensible networking negotiation protocol like [libp2p][libp2p] to allow newer nodes to use newer communication protocols while still allowing older nodes to participate. To avoid the rollback problem that we mentioned before, we have to separate the logic out below the level of consensus. This means we can change <em>only</em> the code that maps transactions to state changes. This does mean that we can&rsquo;t change the fork-choice rule, rollback strategy or consensus algorithm, but we have to make an abstraction tradeoff somewhere. The consensus algorithm can&rsquo;t be changed because it could retroactively make blocks invalid, and we can only allow change things on-chain that affect the state going forward.</p>

<p>For the sake of argument and because you&rsquo;ve probably worked out that I&rsquo;m leading up to something here, let&rsquo;s call this logic the blockchain&rsquo;s &ldquo;runtime&rdquo;. So if we&rsquo;re building a new chain from scratch and we can choose our consensus algorithm and suchlike, we want to make our code as generic as possible. So, we want to allow the runtime to make as many choices as possible. Let&rsquo;s say we want to support both permissioned, private chains and permissionless, public chains (maybe we want to start with a private chain and seamlessly convert it to a public chain later). Well, if we choose a PoA consensus algorithm like Tendermint or PBFT then we can have both, by allowing the runtime to choose the authorities on a per-block basis. I don&rsquo;t have time to full explain PoA here but look for a later article and I can go into it in more depth. Suffice to say that it allows us to create permissioned chains (meaning that only certain parties can participate in the network) and permissionless chains (meaning that anyone can pariticipate in the network), since for PoS we just choose an authority set by a weighted random choice of the stakers. This does mean that we can&rsquo;t run a proof-of-work chain, but for the sake of argument we&rsquo;re only caring about the behaviour of the chain and the method we use to secure the chain should be irrelevant.</p>

<p>The runtime should also be able to make its own decisions on when and how to upgrade, since that allows us to use on-chain governance to do these upgrades. Since the governance is also defined in the runtime, that means that the runtime can choose what the government is allowed to change. Maybe it&rsquo;s not allowed to change the governance structure itself, but everything else is fair game. Maybe it&rsquo;s only allowed to tweak but the basic rules of the system must remain immutable. It&rsquo;s entirely up to the runtime.</p>

<p>This is the approach we&rsquo;ve taken in Parity Substrate, the blockchain development toolkit that we&rsquo;ve built at (no prizes for guessing) Parity. The consensus and networking is handled by Substrate and the chain&rsquo;s logic, authority choice and automatic upgrading is handled by the runtime. Yes, as you&rsquo;ve probably gathered by now, the &ldquo;runtime&rdquo; terminology is copped from Substrate. This also means that you separate the code that affects consensus out, which allows you to have different backends - for example, in Polkadot we can share the Polkadot-specific code between &ldquo;validators&rdquo;, &ldquo;nominators&rdquo;, &ldquo;collators&rdquo; and &ldquo;fishermen&rdquo;. Even though the nodes perform different roles they can all agree on what the state of the network should be and act accordingly. As far as the network is concerned they differ only in the kinds of transactions they submit to the network. Anything that takes data from the outside world - whether it&rsquo;s a report of a node&rsquo;s misbehaviour, a measurement of the weather or a human&rsquo;s desire to send money to another human - is modelled as a transaction and the state is updated as a response to that. We hope that this model can usher in a new era of experimentation in the blockchain space, but that&rsquo;s for you to decide.</p>

</div>

<footer>
	<p>Â© 2017-2018, all rights reserved.</a>
</footer>
</body>
</html>
